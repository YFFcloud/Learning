## 递归
### 递归需要满足的三个条件
* 一个问题的解可以分解为几个子问题的解（子问题就是数据规模更小的问题）
* 这个问题与分解之后的子问题，除了数据规模不一样，求解思路完全相同
* 存在递归终止条件
### 如何编写递归代码
关键点：**写出递归公式，找到终止条件** 之后将递归公式转化为代码
**总结**：
* 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后在推敲终止条件，最后将递推公式和终止条件翻译成代码
* 编写递归代码的关键，只要遇到递归，我们就把它抽象成一个**递推公式**，不用想一层层的调用关系，不要试图用人脑去分解递归的每一个步骤
### 递归代码要警惕堆栈溢出
**原因**：函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

**解决方法**：我们可以通过在代码中**限制递归调用的最大深度**的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。
### 递归代码要警惕重复计算
通过某种数据结构来保存已经求解过的值，从而避免重复计算。
### 如何将递归改写为非递归代码？
笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。

如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。
### 其他问题
* 在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数调用的数量较大时，就会积聚成一个可观的时间成本。
* 在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。
### 递归利弊
* 利：递归代码表达力强，写起来非常简洁
* 弊：空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。
